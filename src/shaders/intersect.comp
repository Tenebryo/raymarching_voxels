#version 450

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(r32f, binding = 0) uniform image2D initialDepthImage;  // depth
layout(rgba32f, binding = 1) uniform image2D nImage;  // normal
layout(rgba32f, binding = 2) uniform image2D pImage;  // world position
layout(r32f, binding = 3) uniform image2D dImage;  // depth
layout(r32ui, binding = 4) uniform uimage2D mImage;   // material index
layout(rgba32ui, binding = 5) uniform uimage2D sImage;   // random seed index
layout(binding = 6) uniform sampler3D blue_noise;   // random seed index

#define VOXEL_BINDING_OFFSET 7
#include "voxel.glsl"

layout(push_constant) uniform IntersectPushConstants {
    vec3 camera_origin;
    uint frame_idx;
    vec3 camera_forward;
    uint max_depth;
    vec3 camera_up;
    float render_dist;
};

const vec3 colors[5] = {
    vec3(0xDC / float(0xFF), 0xE0 / float(0xFF), 0xD9 / float(0xFF)),
    vec3(0x31 / float(0xFF), 0x08 / float(0xFF), 0x1F / float(0xFF)),
    vec3(0x6B / float(0xFF), 0x0F / float(0xFF), 0x1A / float(0xFF)),
    vec3(0x59 / float(0xFF), 0x59 / float(0xFF), 0x59 / float(0xFF)),
    vec3(0x80 / float(0xFF), 0x8F / float(0xFF), 0x85 / float(0xFF))
};


const vec3 colors8[8] = {
    vec3(0.5, 0.0, 0.0), vec3(1.0, 0.0, 0.0),
    vec3(0.0, 0.5, 0.0), vec3(0.0, 1.0, 0.0),
    vec3(0.0, 0.0, 0.5), vec3(0.0, 0.0, 1.0),
    vec3(0.5, 0.5, 0.0), vec3(1.0, 1.0, 0.0),
};

const vec3 INCIDENCE_NORMAL_VECTORS[3] = {vec3(1,0,0), vec3(0,1,0), vec3(0,0,1)};

void main() {
    ivec2 idx = ivec2(
        gl_GlobalInvocationID.x,
        gl_GlobalInvocationID.y
    );

    ivec2 size = imageSize(pImage);

    float aspect_ratio = float(size.x) / float(size.y);

    if (idx.x < size.x && idx.y < size.y) {
        // calculate ray for this pixel by constructing a virtual screen
        vec3 vx = normalize(cross(camera_forward, camera_up));
        vec3 vy = normalize(cross(camera_forward, vx));

        // ND coordinates [0,1]x[0,1]
        vec2 ndc = vec2(idx) / vec2(size);

        // (pseudo) screen space coordinates [-1,1]x[-1,1]
        vec2 ssc = 2 * (ndc - 0.5);

        // the ray direction for this pixel
        vec3 ray_dir = normalize(camera_forward + aspect_ratio * ssc.x * vx + ssc.y * vy);

        ivec2 pre_idx = size / 8;

        float init_depth = min(
            min(
                imageLoad(initialDepthImage, pre_idx).x,
                imageLoad(initialDepthImage, pre_idx + ivec2(1,0)).x
            ),
            min(
                imageLoad(initialDepthImage, pre_idx + ivec2(0,1)).x,
                imageLoad(initialDepthImage, pre_idx + ivec2(1,1)).x
            )
        );

        init_depth = max(init_depth, 0);

        uint incidence = 0;
        float dist = 0;

        vec3 normals[3] = {
            vec3(1,0,0),
            vec3(0,1,0),
            vec3(0,0,1)
        };
        uint vid = 0;
        uint ret;
        uint iter;
        uint material;
        bool hit = voxel_march(camera_origin + ray_dir * init_depth, ray_dir, max_depth, render_dist, dist, incidence, vid, material, ret, iter);

        dist += init_depth;
        vec3 p = camera_origin + ray_dir * dist;
        vec3 n = INCIDENCE_NORMAL_VECTORS[incidence];

        uint seed_shift_0 = idx.x * 531 + idx.y * 73;
        uint seed_shift_1 = idx.x * 91 + idx.y * 347;

        if (hit) {
            imageStore(nImage, idx, vec4(n,1.0));
            imageStore(dImage, idx, vec4(dist));
            imageStore(pImage, idx, vec4(p, 1));
            imageStore(mImage, idx, uvec4(material));
            imageStore(sImage, idx, uvec4(frame_idx + seed_shift_0, mod(frame_idx + seed_shift_1 + 761, 1000007), 0, 0));
        } else {
            imageStore(nImage, idx, vec4(0.0));
            imageStore(dImage, idx, vec4(render_dist+1));
            imageStore(pImage, idx, vec4(camera_origin + ray_dir * render_dist, 0.0));
            imageStore(mImage, idx, uvec4(0));
            imageStore(sImage, idx, uvec4(frame_idx + seed_shift_0, mod(frame_idx + seed_shift_1 + 761, 1000007), 0, 0));
        }
    }
}