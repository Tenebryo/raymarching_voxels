#version 450
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D image;

const uint CHUNK_DIM = 64;
const uint LOG2_CHUNK_DIM = 6;
const uint CHUNK_DIM_MASK = 0x3f;
const uint INCIDENCE_X = 0;
const uint INCIDENCE_Y = 1;
const uint INCIDENCE_Z = 2;

const float EPS = 1e-6;

struct VoxelChunk {
    uint mat[CHUNK_DIM * CHUNK_DIM * CHUNK_DIM / 4];
};

struct Material {
    vec3 color;
    float transparency;
    vec3 emission;
};

layout(binding = 1) buffer VoxelData {
    VoxelChunk chunks[];
} vox;

layout(binding = 2) buffer Materials {
    Material mats[];
} mat;

layout(push_constant) uniform RenderPushConstantData {
    vec3 cam_o;
    vec3 cam_f;
    vec3 cam_u;
    ivec3 vox_chunk_dim;
    uint render_dist;
} pc;

uint get_voxel_mat(int x, int y, int z) {
    
    int cx = x >> LOG2_CHUNK_DIM;
    int cy = y >> LOG2_CHUNK_DIM;
    int cz = z >> LOG2_CHUNK_DIM;

    uint vx = (x >> 2) & CHUNK_DIM_MASK;
    uint vy = y & CHUNK_DIM_MASK;
    uint vz = z & CHUNK_DIM_MASK;

    uint chunk_idx = cx + pc.vox_chunk_dim.x * (cy + pc.vox_chunk_dim.y * cz);
    uint vox_idx = vx + CHUNK_DIM * (vy + CHUNK_DIM * vz);
    uint bit_idx = x & 0x3;

    // get the correct byte
    return (vox.chunks[chunk_idx].mat[vox_idx] >> (8 * bit_idx)) & 0xff;
}

vec3 raymarch(vec3 o, vec3 d) {

    uint max_x = CHUNK_DIM * pc.vox_chunk_dim.x;
    uint max_y = CHUNK_DIM * pc.vox_chunk_dim.y;
    uint max_z = CHUNK_DIM * pc.vox_chunk_dim.z;

    float mx, my, mz, dx, dy, dz, t, dsx, dsy, dsz, ox, oy, oz;
    int sx, sy, sz, hsx, hsy, hsz, x, y, z;
    uint incidence;
    
    // setup calculations for stepping
    sx = int(sign(d.x));
    sy = int(sign(d.y));
    sz = int(sign(d.z));
    
    x = int(floor(o.x));
    y = int(floor(o.y));
    z = int(floor(o.z));
    
    dx = 1.0 / abs(d.x);
    dy = 1.0 / abs(d.y);
    dz = 1.0 / abs(d.z);
    
    hsx = (1 + sx) / 2;
    hsy = (1 + sy) / 2;
    hsz = (1 + sz) / 2;
    
    mx = abs(x + hsx - o.x) * dx;
    my = abs(y + hsy - o.y) * dy;
    mz = abs(z + hsz - o.z) * dz;
    
    // max 
    uint n = pc.render_dist;

    vec3 color = vec3(0.0);
    
    while (n != 0) {
        
        if (mx < my) {
            if (mx < mz) {
                x += sx;
                t = mx;
                incidence = INCIDENCE_X;
                mx += dx;
            } else {
                z += sz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
            } else {
            if (my < mz) {
                y += sy;
                t = my;
                incidence = INCIDENCE_Y;
                my += dy;
            } else {
                z += sz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
        }

        // test if ray is out of bounds of the voxel data in x or z, wrap around.
        // wrap is used so that new voxel chunks can be streamed in without moving existing chunks
        if (x < 0) {x = int(max_x - 1);}
        if (x >= max_x) {x = 0;}
        if (z < 0) {z = int(max_z - 1);}
        if (z >= max_z) {z = 0;}

        // going out of bounds in the y axis means the ray goes to the skybox
        if (y < 0 || max_y <= y) {
            color = vec3(0.0, 0.0, 0.5);
            break;
        }

        // check solidity of voxel
        uint vox_mat = get_voxel_mat(x,y,z);

        if (mat.mats[vox_mat].transparency < EPS) {
            color = vec3(1.0);
            break;
        }

        n -= 1;
    }

    return color;
}

void main() {
    uint idxX = gl_GlobalInvocationID.x;
    uint idxY = gl_GlobalInvocationID.y;

    ivec2 size = imageSize(image);

    if (idxX < size.x && idxY < size.y) {
        // calculate ray for this pixel by constructing a virtual screen
        vec3 vx = normalize(cross(pc.cam_f, pc.cam_u));
        vec3 vy = normalize(cross(pc.cam_f, vx));

        float cx = idxX / float(size.x) - 0.5;
        float cy = idxY / float(size.y) - 0.5;

        vec3 d = pc.cam_f + cx * vx + cy * vy;

        vec3 color = raymarch(pc.cam_o, d);

        imageStore(image, ivec2(idxX,idxY), vec4(color, 1.0));
        // imageStore(image, ivec2(idxX,idxY), vec4(idxX / float(size.x), idxY / float(size.y), 0.0, 1.0));
    }
}