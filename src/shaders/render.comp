#version 450
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 4) uniform image2D ilImage; // indirect lighting color
layout(rgba32f, binding = 5) uniform image2D dlImage; // direct lighting color
layout(rgba32f, binding = 6) uniform image2D nImage;  // normal
layout(rgba32f, binding = 7) uniform image2D pImage;  // world position
layout(rgba32f, binding = 8) uniform image2D dImage;  // depth
layout(r32ui, binding = 9) uniform uimage2D iImage;   // voxel index

layout(binding = 3) uniform sampler2D blue_noise;

// must be a power of 2
layout(constant_id=0) const int BITS_PER_VOXEL = 16;
const int VOXELS_PER_UINT = 32 / BITS_PER_VOXEL;
const int VOXEL_MAT_MASK = (1 << BITS_PER_VOXEL) - 1;

#define PI 3.1415926538

const uint INCIDENCE_X = 0;
const uint INCIDENCE_Y = 1;
const uint INCIDENCE_Z = 2;

const vec3 INCIDENCE_NORMALS[3] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1)
};

const vec3 CHEATY_NORMAL_COLORS[3] = {
    vec3(0.6, 0.6, 0.6),
    vec3(0.7, 0.7, 0.7),
    vec3(0.8, 0.8, 0.8)
};

const uint FLAG_SOLID = 1 << 0;

const float EPS = 1e-6;


struct Material {
    vec3 albedo;
    float transparency;
    vec3 emission;
    uint flags;
    float roughness;
    float shininess;
};

struct PointLight {
    vec3 position;
    float intensity;
    vec3 color;
    float size;
};

layout(binding = 0) buffer VoxelData {
    uint voxels[];
};

layout(binding = 1) buffer Materials {
    Material materials[];
};

layout(binding = 2) buffer PointLights {
    PointLight point_lights[];
};

layout(push_constant) uniform RenderPushConstantData {
    vec3 cam_o;
    float time;
    vec3 cam_f;
    float gamma;
    vec3 cam_u;
    float render_dist;
    ivec3 vdim;
    uint n_point_lights;
};

ivec2 size = ivec2(0);

vec4 blue_noise_sample(ivec2 uv) {
    // return texture(blue_noise, uv / vec2(size));
    return texture(blue_noise, uv / vec2(size) + cos(33 * time) * sin(50 * time));
    // return imageLoad(blue_noise, uv);
    // return vec4(0);
}

vec2 box_muller_transform(vec2 u) {
    float c0 = sqrt(-2 * log(u.x));
    float c1 = 2 * PI * u.y;
    return c0 * vec2(cos(c1), sin(c1));
}

vec4 box_muller_transform(vec4 u) {
    u.wx = box_muller_transform(u.wx);
    u.yz = box_muller_transform(u.yz);

    return u;
}

bool raymarch(vec3 o, vec3 d, out float t, out uint vox_idx, out uint vox_mat, out uint incidence) {

    uint max_x = vdim.x;
    uint max_y = vdim.y;
    uint max_z = vdim.z;

    uint max_xyz = max_x * max_y * max_z;

    
    if (o.y < 0 && d.y > 0) {
        o -= (o.y / d.y) * d;
    }
    if (o.y > max_y && d.y < 0) {
        o -= ((o.y - max_y) / d.y) * d;
    }

    o = vec3(mod(o.x, max_x), o.y, mod(o.z, max_z));

    t = 0;
    
    // setup calculations for stepping
    int sx = int(sign(d.x));
    int sy = int(sign(d.y));
    int sz = int(sign(d.z));
    
    int ix = sx;
    int iy = sy * vdim.x;
    int iz = sz * vdim.x * vdim.y;
    
    int x = int(floor(o.x));
    int y = int(floor(o.y));
    int z = int(floor(o.z));
    
    // 1.0/0.0 == INF in GLSL float implementation, which is convenient for
    // this application
    float dx = 1.0 / abs(d.x);
    float dy = 1.0 / abs(d.y);
    float dz = 1.0 / abs(d.z);
    
    float mx = abs(x + (1 + sx) / 2 - o.x) * dx;
    float my = abs(y + (1 + sy) / 2 - o.y) * dy;
    float mz = abs(z + (1 + sz) / 2 - o.z) * dz;
    
    //calculate the voxel index of the original 
    vox_idx = x + vdim.x * (y + vdim.y * z);

    vec3 color = vec3(0.0);
    
    while (t < render_dist) {
        
        // find the next plane the ray will intersect with. then, increment 
        // the coordinate perpendicular to that plane and change the voxel
        // index accordingly. Also update the length of the ray so far, the
        // last plane orientation crossed, and the axis trackers

        if (mx < my) {
            if (mx < mz) {
                x += sx;
                vox_idx += ix;
                t = mx;
                incidence = INCIDENCE_X;
                mx += dx;
            } else {
                z += sz;
                vox_idx += iz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
        } else {
            if (my < mz) {
                y += sy;
                vox_idx += iy;
                t = my;
                incidence = INCIDENCE_Y;
                my += dy;
            } else {
                z += sz;
                vox_idx += iz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
        }

        // test if ray is out of bounds of the voxel data in x or z, wrap around.
        // wrap is used so that new voxel chunks can be streamed in without moving existing chunks
        if (x < 0) {
            x = int(max_x - 1);
            vox_idx += max_x;
        }
        if (x >= max_x) {
            x = 0;
            vox_idx -= max_x;
        }
        if (z < 0) {
            z = int(max_z - 1);
            vox_idx += max_xyz;
        }
        if (z >= max_z) {
            z = 0;
            vox_idx -= max_xyz;
        }

        // going out of bounds in the y axis means the ray goes to the skybox
        // if (x < 0 || max_x <= x) { return false; }
        if (y < 0 || max_y <= y) { vox_idx = -1; return false; }
        // if (z < 0 || max_z <= z) { return false; }

        // get the material data for the current voxel. GLSL primitives are min 4 bytes, but we
        // don't need 2 billion materials, so we divide each uint into VOXELS_PER_UINT voxels.

        // this is the uint containing VOXELS_PER_UINT voxels
        vox_mat = voxels[vox_idx / VOXELS_PER_UINT];

        // this is the index of the voxel within the uint (we assume that VOXELS_PER_UNIT is a power of 2)
        uint bit_idx = vox_idx & (VOXELS_PER_UINT - 1);

        // we use this to extract the correct voxel material data
        vox_mat = (vox_mat >> (BITS_PER_VOXEL * bit_idx)) & VOXEL_MAT_MASK;

        // check if voxel is solid
        if ((materials[vox_mat].flags & FLAG_SOLID) != 0) {
            return true;
        }
    }
    
    vox_idx = -1; 
    
    return false;
}

vec3 oren_nayar(vec3 n, vec3 dr, vec3 di, vec3 e0, uint m) {
    vec3 albedo = materials[m].albedo;
    float v = materials[m].roughness;
    float vv = v * v;

    dr = normalize(dr);
    di = normalize(di);

    float dot_r = dot(dr, n);
    float dot_i = dot(di, n);

    float tr = acos(dot_r);
    float ti = acos(dot_i);

    vec3 proj_r = normalize(dr - dot_r * n);
    vec3 proj_i = normalize(di - dot_i * n);

    float planar_cos = dot(proj_i, proj_r);

    float alpha = max(tr, ti);
    float beta = min(tr, ti);

    float a = 1 - 0.5 * vv / (vv + 0.33);
    float b = 0.45 * vv / (vv + 0.09);

    vec3 lr = (cos(ti) * (a + b * max(planar_cos, 0) * sin(alpha) * tan(beta)) / PI) * albedo * e0;

    return lr;
}

vec3 blinn_phong(vec3 n, vec3 v, vec3 c, PointLight l, Material m) {

    vec3 ambient_color = vec3(0.1);
    vec3 diffuse_color = m.albedo;
    vec3 spec_color = vec3(1.0);
    vec3 light_color = l.color;

    vec3 di = l.position - v;
    vec3 dr = normalize(c - v);


    float distance = length(di);

    di = normalize(di);

    float lambertian = max(dot(di, n), 0.0);
    float specular = 0.0;

    if (lambertian > 0.0) {

        vec3 dh = normalize(di + dr);

        float spec_angle = max(dot(dh, n), 0.0);

        specular = pow(spec_angle, m.shininess);

    }

    distance *= distance;

    vec3 color_linear = ambient_color +
                        diffuse_color * lambertian * light_color * l.intensity / distance +
                        spec_color * specular * light_color * l.intensity / distance;

    return pow(color_linear, vec3(1.0 / gamma));
}


void main() {
    ivec2 idx = ivec2(
        gl_GlobalInvocationID.x,
        gl_GlobalInvocationID.y
    );

    size = imageSize(ilImage);

    float aspect_ratio = float(size.x) / float(size.y);

    if (idx.x < size.x && idx.y < size.y) {
        // calculate ray for this pixel by constructing a virtual screen
        vec3 vx = normalize(cross(cam_f, cam_u));
        vec3 vy = normalize(cross(cam_f, vx));

        vec2 ndc = vec2(idx) / vec2(size);

        vec2 ssc = 2 * (ndc - 0.5);

        // the ray direction for this pixel
        vec3 d = cam_f + aspect_ratio * ssc.x * vx + ssc.y * vy;

        float ds[3] = {sign(d.x), sign(d.y), sign(d.z)};

        float size_x = float(vdim.x);
        float size_y = float(vdim.y);
        float size_z = float(vdim.z);

        vec3 o = cam_o;

        float depth = 0.0;

        if (o.y < 0 && d.y > 0) {
            depth = (o.y / d.y);
            o -= (o.y / d.y) * d;
        }
        if (o.y > size_y && d.y < 0) {
            depth = ((o.y - size_y) / d.y);
            o -= ((o.y - size_y) / d.y) * d;
        }

        int i = 0;
        vec3 indirect_color = vec3(0.0);
        vec3 direct_color = vec3(0.0);
        vec3 normal = vec3(0.0);
        vec3 position = vec3(0.0);
        uint vox_idx = -1;

        vec3 ambient_light = vec3(0.2);

        if ((o.y < 0 && d.y < 0) || (o.y > size_y && d.y > 0)) {
            indirect_color = vec3(0.5, 0.5, 1.0);
        } else {
            uint vox_mat = 0;
            uint incidence = 0;
            float t = 0;
            bool hit = raymarch(o, d, t, vox_idx, vox_mat, incidence);

            depth += t;


            if (hit) {
                // compute lighting of voxel collision
                // deferred rendering is not needed since there can be no over-shading
                indirect_color = vec3(0.0);
                normal = -ds[incidence] * INCIDENCE_NORMALS[incidence];
                position = o + (t - 1e-3) * d;

                for (int i = 0; i < n_point_lights; i++) {
                    vec3 lp = point_lights[i].position + point_lights[i].size * box_muller_transform(blue_noise_sample(idx)).xyz;

                    indirect_color += blinn_phong(normal, position, cam_o, point_lights[i], materials[vox_mat]);

                    vec3 ld = lp - position;
                    float l_dist = length(ld);
                    ld /= l_dist;
                    float lt = 0.0;
                    uint light_idx = 0;
                    uint light_mat = 0;
                    uint light_incidence = 0;
                    bool occluded = raymarch(position, ld, lt, light_idx, light_mat, light_incidence);

                    if (!occluded) {
                        direct_color += point_lights[i].color * point_lights[i].intensity / (l_dist * l_dist);
                    }
                }
            } else {
                // skybox color
                indirect_color = vec3(0.5, 0.5, 1.0);
            }
        }

        imageStore(ilImage, idx, vec4(indirect_color, 1.0));
        imageStore(dlImage, idx, vec4(direct_color, 1.0));
        imageStore(nImage, idx, vec4(normal, 1.0));
        imageStore(pImage, idx, vec4(position, 1.0));
        imageStore(dImage, idx, vec4(depth));
        imageStore(iImage, idx, uvec4(vox_idx));
    }
}