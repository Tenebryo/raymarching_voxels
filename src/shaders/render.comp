#version 450
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D cImage;
layout(rgba32f, binding = 1) uniform image2D nImage;
layout(rgba32f, binding = 2) uniform image2D pImage;
// layout(rgba32f, binding = 3) readonly uniform image2D blue_noise;
layout(binding = 3) uniform sampler2D blue_noise;

#define PI 3.1415926538

const uint CHUNK_DIM = 64;
const uint LOG2_CHUNK_DIM = 6;
const uint CHUNK_DIM_MASK = 0x3f;
const uint INCIDENCE_X = 0;
const uint INCIDENCE_Y = 1;
const uint INCIDENCE_Z = 2;
const vec3 INCIDENCE_NORMALS[3] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1)
};

const vec3 CHEATY_NORMAL_COLORS[3] = {
    vec3(0.6, 0.6, 0.6),
    vec3(0.7, 0.7, 0.7),
    vec3(0.8, 0.8, 0.8)
};

const uint FLAG_SOLID = 1 << 0;

const float EPS = 1e-6;

struct VoxelChunk {
    uint mat[CHUNK_DIM * CHUNK_DIM * CHUNK_DIM];
};

struct Material {
    vec3 albedo;
    float transparency;
    vec3 emission;
    uint flags;
    float roughness;
};

struct PointLight {
    vec3 position;
    float intensity;
    vec3 color;
    float size;
};

layout(binding = 4) buffer VoxelData {
    VoxelChunk chunks[];
} vox;

layout(binding = 5) buffer Materials {
    Material data[];
} mat;

layout(binding = 6) buffer PointLights {
    PointLight data[];
} point_lights;

layout(push_constant) uniform RenderPushConstantData {
    vec3 cam_o;
    vec3 cam_f;
    float time;
    vec3 cam_u;
    ivec3 vox_chunk_dim;
    uint render_dist;
} pc;

ivec2 size = ivec2(0);

vec4 blue_noise_sample(ivec2 uv) {
    return texture(blue_noise, uv / vec2(size));
    // return texture(blue_noise, uv / vec2(size) + 10.7 * pc.time);
    // return imageLoad(blue_noise, uv);
    // return vec4(0);
}

uint get_voxel_mat(int x, int y, int z) {

    uint bit_idx = x & 0x3;

    int cx = x >> LOG2_CHUNK_DIM;
    int cy = y >> LOG2_CHUNK_DIM;
    int cz = z >> LOG2_CHUNK_DIM;

    uint vx = x & CHUNK_DIM_MASK;
    // uint vx = x & (CHUNK_DIM_MASK >> 2);
    uint vy = y & CHUNK_DIM_MASK;
    uint vz = z & CHUNK_DIM_MASK;

    uint chunk_idx = cx + pc.vox_chunk_dim.x * (cy + pc.vox_chunk_dim.y * cz);
    uint vox_idx = vx + CHUNK_DIM * (vy + CHUNK_DIM * vz);

    // get the correct byte
    // return (vox.chunks[chunk_idx].mat[vox_idx] >> (8 * bit_idx)) & 0xff;
    return vox.chunks[chunk_idx].mat[vox_idx];
}

bool raymarch(vec3 o, vec3 d, out float t, out uint vox_mat, out uint incidence) {

    uint max_x = CHUNK_DIM * pc.vox_chunk_dim.x;
    uint max_y = CHUNK_DIM * pc.vox_chunk_dim.y;
    uint max_z = CHUNK_DIM * pc.vox_chunk_dim.z;

    
    if (o.y < 0 && d.y > 0) {
        o -= (o.y / d.y) * d;
    }
    if (o.y > max_y && d.y < 0) {
        o -= ((o.y - max_y) / d.y) * d;
    }

    o = vec3(mod(o.x, max_x), o.y, mod(o.z, max_z));

    t = 0;

    float mx, my, mz, dx, dy, dz, dsx, dsy, dsz, ox, oy, oz;
    int sx, sy, sz, hsx, hsy, hsz, x, y, z;
    
    // setup calculations for stepping
    sx = int(sign(d.x));
    sy = int(sign(d.y));
    sz = int(sign(d.z));
    
    x = int(floor(o.x));
    y = int(floor(o.y));
    z = int(floor(o.z));
    
    dx = 1.0 / abs(d.x);
    dy = 1.0 / abs(d.y);
    dz = 1.0 / abs(d.z);
    
    hsx = (1 + sx) / 2;
    hsy = (1 + sy) / 2;
    hsz = (1 + sz) / 2;
    
    mx = abs(x + hsx - o.x) * dx;
    my = abs(y + hsy - o.y) * dy;
    mz = abs(z + hsz - o.z) * dz;
    
    // max 
    uint n = pc.render_dist;

    vec3 color = vec3(0.0);
    
    while (n != 0) {
        
        if (mx < my) {
            if (mx < mz) {
                x += sx;
                t = mx;
                incidence = INCIDENCE_X;
                mx += dx;
            } else {
                z += sz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
            } else {
            if (my < mz) {
                y += sy;
                t = my;
                incidence = INCIDENCE_Y;
                my += dy;
            } else {
                z += sz;
                t = mz;
                incidence = INCIDENCE_Z;
                mz += dz;
            }
        }

        // test if ray is out of bounds of the voxel data in x or z, wrap around.
        // wrap is used so that new voxel chunks can be streamed in without moving existing chunks
        if (x < 0) {x = int(max_x - 1);}
        if (x >= max_x) {x = 0;}
        if (z < 0) {z = int(max_z - 1);}
        if (z >= max_z) {z = 0;}

        // going out of bounds in the y axis means the ray goes to the skybox
        if (y < 0 || max_y <= y) {
            return false;
        }

        // check solidity of voxel
        vox_mat = get_voxel_mat(x,y,z);

        // check if voxel is solid
        if ((mat.data[vox_mat].flags & FLAG_SOLID) != 0) {
            return true;
        }

        n -= 1;
    }

    return false;
}

vec3 oren_nayar(vec3 n, vec3 dr, vec3 di, vec3 e0, uint m) {
    vec3 albedo = mat.data[m].albedo;
    float v = mat.data[m].roughness;
    float vv = v * v;

    dr = normalize(dr);
    di = normalize(di);

    float dot_r = dot(dr, n);
    float dot_i = dot(di, n);

    float tr = acos(dot_r);
    float ti = acos(dot_i);

    vec3 proj_r = normalize(dr - dot_r * n);
    vec3 proj_i = normalize(di - dot_i * n);

    float planar_cos = dot(proj_i, proj_r);

    float alpha = max(tr, ti);
    float beta = min(tr, ti);

    float a = 1 - 0.5 * vv / (vv + 0.33);
    float b = 0.45 * vv / (vv + 0.09);

    vec3 lr = (cos(ti) * (a + b * max(planar_cos, 0) * sin(alpha) * tan(beta)) / PI) * albedo * e0;

    return lr;
}


void main() {
    ivec2 idx = ivec2(
        gl_GlobalInvocationID.x,
        gl_GlobalInvocationID.y
    );

    size = imageSize(cImage);

    if (idx.x < size.x && idx.y < size.y) {
        // calculate ray for this pixel by constructing a virtual screen
        vec3 vx = normalize(cross(pc.cam_f, pc.cam_u));
        vec3 vy = normalize(cross(pc.cam_f, vx));

        vec2 screen_coord = vec2(idx) / vec2(size);

        float cx = screen_coord.x - 0.5;
        float cy = screen_coord.y - 0.5;

        // the ray direction for this pixel
        vec3 d = pc.cam_f + cx * vx + cy * vy;

        float size_x = float(CHUNK_DIM * pc.vox_chunk_dim.x);
        float size_y = float(CHUNK_DIM * pc.vox_chunk_dim.y);
        float size_z = float(CHUNK_DIM * pc.vox_chunk_dim.z);

        vec3 o = pc.cam_o;
    
        if (o.y < 0 && d.y > 0) {
            o -= (o.y / d.y) * d;
        }
        if (o.y > size_y && d.y < 0) {
            o -= ((o.y - size_y) / d.y) * d;
        }

        int i = 0;
        vec3 color = vec3(0.0);
        vec3 normal = vec3(0.0);
        vec3 position = vec3(0.0);

        vec3 ambient_light = vec3(0.1);

        if ((o.y < 0 && d.y < 0) || (o.y > size_y && d.y > 0)) {
            color = vec3(0.5, 0.5, 1.0);
        } else {
            float t = 0;
            uint vox_mat = 0;
            uint incidence = 0;
            bool hit = raymarch(o, d, t, vox_mat, incidence);

            if (hit) {
                normal = INCIDENCE_NORMALS[incidence];
                position = o + (t - 1e-3) * d;
                vec3 lp = point_lights.data[0].position + point_lights.data[0].size * blue_noise_sample(idx).xyz;

                vec3 ld = lp - position;
                float l_dist = length(ld);
                ld /= l_dist;
                float lt = 0.0;
                uint light_mat = 0;
                uint light_incidence = 0;
                bool occluded = raymarch(position, ld, lt, light_mat, light_incidence);

                if (occluded) {
                    color = ambient_light * CHEATY_NORMAL_COLORS[incidence];
                } else {
                    color = CHEATY_NORMAL_COLORS[incidence];
                    
                    // color = oren_nayar(n, -d, ld, point_lights.data[0].color, vox_mat);
                }
            } else {
                color = vec3(0.5, 0.5, 1.0);
            }
        }
        imageStore(cImage, idx, vec4(color, 1.0));
        imageStore(nImage, idx, vec4(normal, 1.0));
        imageStore(pImage, idx, vec4(position, 1.0));
    }
}