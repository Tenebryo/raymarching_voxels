#version 450
///functions that compute a single sample of the lighting function for a pixel
/// Implements bidirectional path tracing with importance sampling


#define PI 3.141592653

struct PointLight {
    vec3 position;
    float power;
    vec3 color;
    float radius;
};

struct DirectionalLight {
    vec3 direction;
    vec3 color;
};

struct SpotLight {
    vec3 position;
    float power;
    vec3 direction;
    float half_angle;
    vec3 color;
};

/// BRDF 
struct BRDF {
    /// resolution of brdf
    uint n;
    /// factor terms
    uint l;

    // pdf and cdf indices
    /// index of the 2*n*n*l outgoing ray matrix
    uint f_idx;
    /// index of the 2*l*n incoming ray matrix theta factor
    uint u_idx;
    /// index of the 2*l*n incoming ray matrix phi factor
    uint v_idx;
};

struct Material {
    BRDF brdf;
    vec3 albedo;
    float transparency;
    vec3 emission;
    uint flags;
    float roughness;
    float shininess;
};

//material information
layout(binding = 0) readonly buffer MaterialData {
    Material materials[];
};

layout(binding = 1) readonly buffer BRDFData {
    float brdf_values[];
};

// lighting data
layout(binding = 2) readonly buffer PointLightData{
    PointLight point_lights[];
};
layout(binding = 3) readonly buffer DirectionalLightData{
    DirectionalLight directional_lights[];
};
layout(binding = 4) readonly buffer SpotLightData{
    SpotLight spots_lights[];
};


// g-buffer information
layout(rgba32f, binding = 5) readonly uniform image2D intersections;
layout(rgba32f, binding = 6) readonly uniform image2D normals;
layout(r32f, binding = 7) readonly uniform image2D depth;
layout(r32ui, binding = 8) readonly uniform uimage2D material;
layout(rgba32f, binding = 9) uniform image2D lighting;
layout(rgba32ui, binding = 10) uniform uimage2D seeds;


// voxel geometry information and functions
#define VOXEL_BINDING_OFFSET 11
#include "voxel.glsl"

layout(push_constant) uniform LightingPushConstantData {
    vec3 ambient_light;
    uint n_point_lights;
    vec3 camera_origin;
    uint n_directional_lights;
    vec3 camera_forward;
    uint n_spot_lights;
    vec3 camera_up;
    float render_dist;
};

// brdf indexing functions
uint brdf_index_f_pdf(BRDF brdf, uint ti, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.f_idx + li + l * (pi + n * ti);
}

uint brdf_index_f_cdf(BRDF brdf, uint ti, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.f_idx + li + l * (pi + n * (ti + n));
}

uint brdf_index_u_pdf(BRDF brdf, uint ti, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.u_idx + ti + n * li;
}

uint brdf_index_u_cdf(BRDF brdf, uint ti, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.u_idx + ti + n * (li + l);
}

uint brdf_index_v_pdf(BRDF brdf, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.v_idx + pi + n * li;
}

uint brdf_index_v_cdf(BRDF brdf, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf.v_idx + pi + n * (li + l);
}

// brdf value functions (gets the value of the BDRF factors at certain points)
float brdf_value_f_pdf(BRDF brdf, uint ti, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_f_pdf(brdf, ti, pi, li)];
}

float brdf_value_f_cdf(BRDF brdf, uint ti, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_f_cdf(brdf, ti, pi, li)];
}

float brdf_value_u_pdf(BRDF brdf, uint ti, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_u_pdf(brdf, ti, li)];
}

float brdf_value_u_cdf(BRDF brdf, uint ti, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_u_cdf(brdf, ti, li)];
}

float brdf_value_v_pdf(BRDF brdf, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_v_pdf(brdf, pi, li)];
}

float brdf_value_v_cdf(BRDF brdf, uint pi, uint li) {
    uint n = brdf.n;
    uint l = brdf.l;
    return brdf_values[brdf_index_v_cdf(brdf, pi, li)];
}

/// get the density of the BRDF with the outbound and parameterized (half angle) incoming ray
float brdf_pdf_p(BRDF brdf, float theta_o, float phi_o, float theta_p, float phi_p) {

    int theta_o_i = int(theta_o / PI * brdf.n);
    int theta_p_i = int(theta_p / PI * brdf.n);
    
    int phi_o_i = int(phi_o / PI * 0.5 * brdf.n);
    int phi_p_i = int(phi_p / PI * 0.5 * brdf.n);

    float nsum = 0;
    float dsum = 0;

    for (uint li = 0; li < brdf.l; li++) {
        float fv = brdf_value_f_pdf(brdf, theta_o_i, phi_o_i, li);
        float uv = brdf_value_u_pdf(brdf, theta_p_i, li);
        float vv = brdf_value_u_pdf(brdf, phi_p_i, li);

        nsum += fv * uv * vv;
        dsum += fv;
    }

    return nsum / dsum;
}

/// calculate the incidence angle from factorization index.
///  * `theta` : the `theta` parameter
///  * `phi` : the `phi` parameter
///  * `theta_i` : out parameter for the `u` factor index
///  * `phi_i` : out parameter for the `v` factor index
void brdf_angle_to_index(BRDF brdf, float theta, float phi, out uint theta_i, out uint phi_i) {
    theta_i = int(theta / PI * brdf.n);
    phi_i = int(phi / PI * 0.5 * brdf.n);
}

/// calculate the half-angle parameterization from factorization index.
///  * `z` : the `z` parameter
///  * `phi` : the `phi` parameter
///  * `zi` : out parameter for the `u` factor index
///  * `phi_i` : out parameter for the `v` factor index
void brdf_half_angle_to_index(BRDF brdf, float z, float phi, out uint zi, out uint phi_i) {
    zi = int(brdf.n * (z + 1) * 0.5);
    phi_i = int(phi / PI * 0.5 * brdf.n);
}

/// calculate the incidence angle from factorization index.
///  * `theta_i` : the `u` factor index
///  * `phi_i` : the `v` factor index
///  * `theta` : out parameter for the `theta` parameter
///  * `phi` : out parameter for the `phi` parameter
void brdf_index_to_angle(BRDF brdf, uint theta_i, uint phi_i, out float theta, out float phi) {
    theta = PI * theta_i / float(brdf.n);
    phi = 2.0 * PI * phi_i / float(brdf.n);
}

/// calculate the half-angle parameterization from factorization index.
///  * `zi` : the `u` factor index
///  * `phi_i` : the `v` factor index
///  * `z` : out parameter for the `z` parameter
///  * `phi` : out parameter for the `phi` parameter
void brdf_index_to_half_angle(BRDF brdf, uint zi, uint phi_i, out float z, out float phi) {
    z = 2.0 * zi / float(brdf.n) - 1;
    phi = 2.0 * PI * phi_i / float(brdf.n);
}

/// calculate the half-angle vector from two incident vectors (normalized)
vec3 calculate_half_angle_from_incidents(vec3 o, vec3 i) {
    return normalize(o + i);
}

/// calculate the other incident direction from one incident vector and the half-angle vector
///  * `o` : the given incident vector (normalized)
///  * `h` : the half angle vector (normalized)
vec3 calculate_incident_from_half_angle(vec3 o, vec3 h) {
    vec3 prj = o - dot(h, o) * h;
    return o - 2 * prj;
}

/// computes the theta and phi angles for an incident ray
///  * `n` : the normal vector (normalized)
///  * `p` : a parallel vector (normalized)
///  * `i` : the incident vector (normalized)
vec2 incident_angles_from_vector(vec3 n, vec3 p, vec3 i) {
    vec3 q = cross(n, p);
    float dqi = dot(q, i);

    // project onto plane
    vec3 nprj = dot(n, i) * n;
    vec3 pprj = dot(p, i) * p;
    vec3 qprj = dqi * q;


    float theta = acos(dot(p, normalize(nprj + pprj)));
    float phi = acos(dot(p, normalize(pprj + qprj))) * sign(dqi);

    return vec2(theta, phi);
}
/// computes the theta and phi angles for an incident ray
///  * `n` : the normal vector (normalized)
///  * `p` : a parallel vector (normalized)
///  * `i` : the incident vector (normalized)
vec3 vector_from_incident_angles(vec3 n, vec3 p, float theta, float phi) {
    vec3 q = cross(n, p);

    float cos_theta = cos(theta);

    return (sin(theta)) * n + (cos_theta * cos(phi)) * p + (cos_theta * sin(phi)) * q;
}

/// Sample a vector from the BRDF conditioned on the outbound ray defined by azimuthal and elevation angles
/// and 3 random numbers in the range [0,1)
/// An incoming ray is sampled and returned in the same format vec2(theta, phi);
vec2 sample_brdf(BRDF brdf, float theta_o, float phi_o, float r0, float r1, float r2) {
    // TODO: replace linear search with binary search. this is currently not a huge bottleneck because raymarching is much slower
    uint fi, ui, vi;

    uint theta_i;
    uint phi_i;

    brdf_angle_to_index(brdf, theta_o, phi_o, theta_i, phi_i);

    // use first random number to select the factor index:
    for(fi = 0; fi < brdf.l; fi++) {
        float fv = brdf_value_f_cdf(brdf, theta_i, phi_i, fi);
        if (r0 < fv) {
            break;
        }
    }

    // use the second and third random numbers to select the ray direction
    for(ui = 0; ui < brdf.n; ui++) {
        float uv = brdf_value_u_cdf(brdf, ui, fi);
        if (r1 < uv) {
            break;
        }
    }
    
    for(vi = 0; vi < brdf.n; vi++) {
        float vv = brdf_value_v_cdf(brdf, vi, fi);
        if (r2 < vv) {
            break;
        }
    }
    

    // convert the sampled indices to a ray vector 
    float z, phi;
    brdf_index_to_half_angle(brdf, ui, vi, z, phi);

    float theta = acos(z);

    return vec2(theta, phi);
}

vec3 sample_point_light(uint l, uint seed) {
    return vec3(0);
}

vec3 contribution_from_light() {
    return vec3(0);
}

vec3 halton_sequence3(uint index, uvec3 base) {
    float f = 1;
    vec3 r = vec3(0);

    uint i = index;
    while (i > 0) {
        f = f / base.x;
        r.x += f * mod(i, base.x);
    }

    f = 1;
    i = index;
    while (i > 0) {
        f = f / base.y;
        r.y += f * mod(i, base.y);
    }

    f = 1;
    i = index;
    while (i > 0) {
        f = f / base.z;
        r.z += f * mod(i, base.z);
    }

    return r;
}

vec3 lighting_from_point(Material mat, vec3 point, vec3 normal, vec3 parallel, vec3 incident, uint seed) {

    vec3 light_integral = mat.emission;

    // iterate through some or all lights and integrate their contributions
    for (int i = 0; i < n_directional_lights; i++) {
        uint max_depth = 5;
        float dist;
        uint incidence;
        uint vox_id;
        uint ret;
        uint iterations;

        bool hit = voxel_march(point, -directional_lights[i].direction, max_depth, render_dist, dist, incidence, vox_id, ret, iterations);

        // directional lights illuminate when the light misses any voxel geometry.
        if (!hit) {
            light_integral += directional_lights[i].color;
        }
    }

    return light_integral;
}

const vec3 INCIDENCE_NORMAL_VECTORS[3] = {vec3(1,0,0), vec3(0,1,0), vec3(0,0,1)};

/// do multiple importance path tracing with 
void main() {
    ivec2 idx = ivec2(
        gl_GlobalInvocationID.x,
        gl_GlobalInvocationID.y
    );

    ivec2 size = imageSize(intersections);

    float aspect_ratio = float(size.x) / float(size.y);

    vec3 light_integral = vec3(0);

    // use a while loop for early breakout of
    if (idx.x < size.x && idx.y < size.y) {
        while (true) {
            vec4  p = imageLoad(intersections, idx);
            vec4  n = imageLoad(normals, idx);
            vec4  d = imageLoad(depth, idx);
            uvec4 m = imageLoad(material, idx);
            uvec4 s = imageLoad(seeds, idx);

            vec3 out_0 = camera_origin - p.xyz;

            // generate some pseudo random numbers
            vec3 rv0 = halton_sequence3(s.x, uvec3(2,3,5));
            vec3 rv1 = halton_sequence3(s.x + 1000007, uvec3(2,3,5));

            if (d.x > render_dist) {
                // render skybox if there isn't an intersection
                light_integral = vec3(0.1);
                break;
            }

            // sample 1 bounces from brdf (6 random numbers)

            vec2 o_angles_0 = incident_angles_from_vector(n.xyz, n.zxy, out_0);
            vec2 i_angles_0 = sample_brdf(materials[m.x].brdf, o_angles_0.x, o_angles_0.y, rv0.x, rv0.y, rv0.z);
            vec3 in_0 = vector_from_incident_angles(n.xyz, n.zxy, i_angles_0.x, i_angles_0.y);

            vec3 p0 = p.xyz;

            uint max_depth = 10;
            float dist;
            uint incidence;
            uint vox_id;
            uint code;
            uint iterations;

            bool hit = voxel_march(p0, in_0, max_depth, render_dist, dist, incidence, vox_id, code, iterations);
            
            vec3 p1 = p0 + in_0 * dist;

            // sample lighting to the two points:
            // * choose a random light and sample a point from the light surface
            // * cast rays from path intersection points to the chosen light point
            // * calculate light contributions

            uint li = s.y % (n_directional_lights + n_point_lights + n_spot_lights);
            uint l_type = 0;

            if (li >= n_directional_lights) {
                l_type++;
                li -= n_directional_lights;
            }
            if (li >= n_point_lights) {
                l_type++;
                li -= n_point_lights;
            }

            vec3 lcolor = vec3(0);
            vec3 ldir0 = vec3(0);
            vec3 ldir1 = vec3(0);
            float lpow0 = 0;
            float lpow1 = 0;
            float dist0 = 0;
            float dist1 = 0;
            // calculate light type-dependent values separately 
            switch (l_type) {
                case 0:
                    // directional light
                    ldir0 = directional_lights[li].direction;
                    ldir1 = directional_lights[li].direction;

                    dist0 = render_dist;
                    dist1 = render_dist;

                    lpow0 = 1;
                    lpow1 = 1;

                    lcolor = directional_lights[li].color;
                    break;
                case 1:
                    // point light. for now assume perfect point lights
                    ldir0 = point_lights[li].position - p0;
                    ldir1 = point_lights[li].position - p1;
                    
                    dist0 = length(ldir0);
                    dist1 = length(ldir1);

                    ldir0 = normalize(ldir0);
                    ldir1 = normalize(ldir1);

                    lpow0 = point_lights[li].power / (dist0 * dist0);
                    lpow1 = point_lights[li].power / (dist1 * dist1);
                    
                    lcolor = point_lights[li].color;
                    break;
                case 2:
                    // spot light. for now assume perfect point lights
                    ldir0 = spots_lights[li].position - p0;
                    ldir1 = spots_lights[li].position - p1;

                    dist0 = length(ldir0);
                    dist1 = length(ldir1);

                    ldir0 = normalize(ldir0);
                    ldir1 = normalize(ldir1);

                    lpow0 = max(0, pow(dot(spots_lights[li].direction, -ldir0), 3)) * spots_lights[li].power / (dist0 * dist0);
                    lpow1 = max(0, pow(dot(spots_lights[li].direction, -ldir1), 3)) * spots_lights[li].power / (dist1 * dist1);

                    lcolor = spots_lights[li].color;
                    break;
                default:
                    //error
                    break;
            }

            if (!hit) {
                // if there isn't a second intersection, we just render the skybox from tha
                dist1 = 0;
            }

            uint max_depth_light = 5;
            float ldist0, ldist1;
            uint lincidence0, lincidence1;
            uint lvox_id0, lvox_id1;
            uint lcode0, lcode1;
            uint liter0, liter1;

            uint vmat0 = m.x;
            uint vmat1 = vox_id;

            // calculate the normal vectors at 2
            vec3 norm0 = n.xyz;
            vec3 norm1 = INCIDENCE_NORMAL_VECTORS[incidence];

            // initialize the outbound light integral for the first intersection
            vec3 light_integral_0 = vec3(materials[vmat0].emission) * dot(norm0, normalize(camera_origin - p0));

            // raymarch from the first intersection to the light
            bool hit0 = voxel_march(p0, ldir0, max_depth_light, dist0+0.1, ldist0, lincidence0, lvox_id0, lcode0, liter0);

            // calculate brdf pdf value for light contribution to the first intersection
            vec2 oa_0 = incident_angles_from_vector(norm0.xyz, norm0.zxy, -in_0);
            vec2 ia_0 = incident_angles_from_vector(norm0.xyz, norm0.zxy, calculate_half_angle_from_incidents(-in_0, ldir0));
            float brdf_pdf_0 = brdf_pdf_p(materials[vmat0].brdf, oa_0.x, oa_0.y, ia_0.x, ia_0.x);

            if (hit0) {
                // if we collide with a voxel in the path to the light, at least contribute it's emission value
                light_integral_0 += brdf_pdf_0 * vec3(materials[lvox_id0].emission) * dot(INCIDENCE_NORMAL_VECTORS[lincidence0], -ldir0);
            } else {
                // if there is a path to the light, it contributes to the outbound light
                light_integral_0 += brdf_pdf_0 * lcolor * lpow0;
            }

            bool hit1;
            vec3 light_integral_1;
            // if there is a second intersection,
            if (hit) {
                // initialize the outbound light integral for the second intersection
                light_integral_1 = vec3(materials[vmat1].emission) * dot(norm1, -normalize(in_0));

                // raymarch from the second intersection to the light
                hit1 = voxel_march(p1, ldir1, max_depth_light, dist1+0.1, ldist1, lincidence1, lvox_id1, lcode1, liter1);

                // calculate brdf pdf value for light contribution to the second intersection
                vec2 oa_1 = incident_angles_from_vector(norm1.xyz, norm1.zxy, -ldir0);
                vec2 ia_1 = incident_angles_from_vector(norm1.xyz, norm1.zxy, calculate_half_angle_from_incidents(-ldir0, ldir1));
                float brdf_pdf_1 = brdf_pdf_p(materials[vmat1].brdf, oa_0.x, oa_0.y, ia_0.x, ia_0.x);
                if (hit1) {
                    // if we collide with a voxel in the path to the light, at least contribute it's emission value
                    light_integral_1 += brdf_pdf_1 * vec3(materials[lvox_id1].emission) * dot(INCIDENCE_NORMAL_VECTORS[lincidence1], -ldir1);
                } else {
                    // if there is a path to the light, it contributes to the outbound light
                    light_integral_1 += brdf_pdf_0 * lcolor * lpow0;
                }

            } else {
                // if there is no second intersection, take the skybox illumination
                light_integral_1 = vec3(0.1);
                hit1 = false;
            }
            // contribute the outbound light integral of the second intersection to that first intersection, and that of the first intersection to the pixel
            // because of importance sampling, there is no incidence angle terms because those terms are inherent in the sampling method (over time and adjacent pixels)
            light_integral += light_integral_0 + light_integral_1;

            break;
        }
        imageStore(lighting, idx, vec4(light_integral, 1));
    }
}